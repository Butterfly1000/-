这个专题是针对Mysql的innodb引擎的。

我们知道innodb是支持行级锁，但它也支持表级锁哦~（现在也是Mysql的默认引擎）

行级锁和表级锁的区别
行级锁只锁住命中的行，而表级锁是对整个表加锁。

innodb引擎的insert,update,delete操作都会给操作数据加上排他锁(理想状态:行级锁).这时候其他事务是没法对这行数据进行操作的。这边的行级锁是理想状态哦，
要看匹配的列是不是有索引,因为有索引才能加行锁，不然的话就是加表锁。

那么，Mysql 执行select查询语句的时候 会自动加锁吗？

MySQL的InnoDB引擎的行锁和表锁
★行锁和表锁
1.Mysql的行锁是通过索引加载的，即行锁是加在索引响应的行上，要是对应的SQL语句没有走索引，则会全表扫描，这时候就是表锁了;

2.表锁：不会出现死锁，发生锁冲突几率高，并发低;（整张表都锁了，其他访问不了，自然就有冲突，并发也就低了）

3.行锁：会出现死锁，发生锁冲突几率低，并发高;（只锁住索引响应命中行，其他行不影响，自然冲突相比表锁少，并发高）

4.锁冲突：例如说事务A将某几行上锁后，事务B又对其上锁，锁不能共存否则会出现锁冲突。（但是共享锁可以共存，共享锁和排它锁不能共存，排它锁和排它锁也
不可以）;

5.死锁：例如说两个事务，事务A锁住了1~5行，同时事务B锁住了6~10行，此时事务A请求锁住6~10行，就会阻塞直到事务B施放6~10行的锁，而随后事务B又请求锁
住1~5行，事务B也阻塞直到事务A释放1~5行的锁。死锁发生时，会产生Deadlock错误。

6.锁是对表操作的，所以锁住全表的表锁就不会出现死锁。

★行锁的类型
1.行锁分 共享锁 和 排它锁。

2.共享锁(又称：读锁)，当一个事务对某几行上读锁时，允许其他事务对这几行进行读操作，但不允许其进行写操作，也不允许其他事务给这几行上排它锁，
但允许上读锁。

3.排它锁(又称：写锁)，当一个事务对某几个上写锁时，不允许其他事务写，但允许读。更不允许其他事务给这几行上任何锁,包括写锁。

4.
上共享锁的写法：lock in share mode

例如： select  math from zje where math>60 lock in share mode；

上排它锁的写法：for update

例如：select math from zje where math >60 for update；

★行锁的实现
注意几点：
1.行锁必须有索引才能实现，否则会自动锁全表，那么就不是行锁了，是表锁。

2.两个事务不能锁同一个索引，例如：
事务A先执行：
select math from test_table where math>60 for update;
 
事务B再执行：
select math from test_table where math<60 for update；
这样的话，事务B是会阻塞的。如果事务B把 math索引换成其他索引就不会阻塞，但注意，换成其他索引锁住的行不能和math索引锁住的行有重复。

3.insert，delete，update在事务中都会自动默认加上排它锁。
实现：
会话1：
begin；
select  math  from zje where math>60 for update；    

会话2：
begin；
update zje set math=99 where math=68；
阻塞...........

会话相当于用户请求，如上，会话1先把zje表中math>60的行上排它锁。然后会话2试图把math=68的行进行修改，math=68处于math>60中，所以是已经被锁的，
会话2进行操作时，就会阻塞，等待会话1把锁释放。当commit时或者程序结束时，会释放锁。





参考/转载文档:
https://blog.csdn.net/qq_32252917/article/details/83451550
